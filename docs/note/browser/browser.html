<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器原理 | 前端攻城手册</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="前端攻城狮的攻城宝典">
    
    <link rel="preload" href="/mynote/assets/css/0.styles.4607b592.css" as="style"><link rel="preload" href="/mynote/assets/js/app.7fa68d6d.js" as="script"><link rel="preload" href="/mynote/assets/js/3.50452af2.js" as="script"><link rel="preload" href="/mynote/assets/js/1.6e2e339d.js" as="script"><link rel="preload" href="/mynote/assets/js/37.5acf7413.js" as="script"><link rel="prefetch" href="/mynote/assets/js/10.e8e79b0e.js"><link rel="prefetch" href="/mynote/assets/js/11.aedcb26b.js"><link rel="prefetch" href="/mynote/assets/js/12.bd2d41ad.js"><link rel="prefetch" href="/mynote/assets/js/13.ba06aa5a.js"><link rel="prefetch" href="/mynote/assets/js/14.8960dcba.js"><link rel="prefetch" href="/mynote/assets/js/15.6577bd04.js"><link rel="prefetch" href="/mynote/assets/js/16.a5ac289a.js"><link rel="prefetch" href="/mynote/assets/js/17.32a6e9ff.js"><link rel="prefetch" href="/mynote/assets/js/18.32535bd6.js"><link rel="prefetch" href="/mynote/assets/js/19.fcc1b0ce.js"><link rel="prefetch" href="/mynote/assets/js/20.e74f20b4.js"><link rel="prefetch" href="/mynote/assets/js/21.aa56cef1.js"><link rel="prefetch" href="/mynote/assets/js/22.907ab2eb.js"><link rel="prefetch" href="/mynote/assets/js/23.36975004.js"><link rel="prefetch" href="/mynote/assets/js/24.26908191.js"><link rel="prefetch" href="/mynote/assets/js/25.df4fb07c.js"><link rel="prefetch" href="/mynote/assets/js/26.a1a22e20.js"><link rel="prefetch" href="/mynote/assets/js/27.f6cdb781.js"><link rel="prefetch" href="/mynote/assets/js/28.fa33413c.js"><link rel="prefetch" href="/mynote/assets/js/29.61f42e66.js"><link rel="prefetch" href="/mynote/assets/js/30.88dbea18.js"><link rel="prefetch" href="/mynote/assets/js/31.f258b7aa.js"><link rel="prefetch" href="/mynote/assets/js/32.9764e859.js"><link rel="prefetch" href="/mynote/assets/js/33.fd82cfe7.js"><link rel="prefetch" href="/mynote/assets/js/34.9a302850.js"><link rel="prefetch" href="/mynote/assets/js/35.f2fb6263.js"><link rel="prefetch" href="/mynote/assets/js/36.f281f45c.js"><link rel="prefetch" href="/mynote/assets/js/38.2561cc0e.js"><link rel="prefetch" href="/mynote/assets/js/39.8fcb2d5f.js"><link rel="prefetch" href="/mynote/assets/js/4.864a582c.js"><link rel="prefetch" href="/mynote/assets/js/40.e3d7f3bf.js"><link rel="prefetch" href="/mynote/assets/js/41.56d15d6b.js"><link rel="prefetch" href="/mynote/assets/js/42.1934065a.js"><link rel="prefetch" href="/mynote/assets/js/43.137ebda5.js"><link rel="prefetch" href="/mynote/assets/js/44.0a9926ca.js"><link rel="prefetch" href="/mynote/assets/js/45.642669fe.js"><link rel="prefetch" href="/mynote/assets/js/46.66b70397.js"><link rel="prefetch" href="/mynote/assets/js/47.b70409c3.js"><link rel="prefetch" href="/mynote/assets/js/48.c12d8944.js"><link rel="prefetch" href="/mynote/assets/js/49.c3cef91e.js"><link rel="prefetch" href="/mynote/assets/js/5.fddfa697.js"><link rel="prefetch" href="/mynote/assets/js/50.ab2b77dd.js"><link rel="prefetch" href="/mynote/assets/js/51.8f585a76.js"><link rel="prefetch" href="/mynote/assets/js/52.536e4178.js"><link rel="prefetch" href="/mynote/assets/js/6.2be0eba5.js"><link rel="prefetch" href="/mynote/assets/js/7.301cf754.js"><link rel="prefetch" href="/mynote/assets/js/8.325e8c11.js"><link rel="prefetch" href="/mynote/assets/js/9.8da6cccf.js">
    <link rel="stylesheet" href="/mynote/assets/css/0.styles.4607b592.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>前端攻城手册</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>前端攻城狮的攻城宝典</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mynote/" class="home-link router-link-active"><!----> <span class="site-name">前端攻城手册</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mynote/docs/note/CSS/CSS.html" class="nav-link"><i class="iconfont reco-tag"></i>
  知识点
</a></div><div class="nav-item"><a href="/mynote/docs/face/collect.html" class="nav-link"><i class="iconfont reco-tag"></i>
  面经
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><!----> <!----> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>42</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>0</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/mynote/docs/note/CSS/CSS.html" class="nav-link"><i class="iconfont reco-tag"></i>
  知识点
</a></div><div class="nav-item"><a href="/mynote/docs/face/collect.html" class="nav-link"><i class="iconfont reco-tag"></i>
  面经
</a></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/CSS/CSS.html" class="sidebar-heading clickable"><span>CSS</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/HTML/HTML.html" class="sidebar-heading clickable"><span>HTML</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/JavaScript/JavaScript.html" class="sidebar-heading clickable"><span>JavaScript</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/NodeJs/Node.html" class="sidebar-heading clickable"><span>NodeJs</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/ThreeJs/ThreeJs.html" class="sidebar-heading clickable"><span>ThreeJs</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/Vue/Vue.html" class="sidebar-heading clickable"><span>Vue</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/Computer-network/Computer-network.html" class="sidebar-heading clickable"><span>计算机网络</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/browser/browser.html" aria-current="page" class="sidebar-heading clickable router-link-exact-active router-link-active open active"><span>浏览器</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/mynote/docs/note/browser/browser.html" aria-current="page" class="active sidebar-link">浏览器原理</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/engineering&amp;optimization/optimization.html" class="sidebar-heading clickable"><span>前端工程化和优化</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/writeCode/writecode.html" class="sidebar-heading clickable"><span>手撕代码</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/note/false/about-this.html" class="sidebar-heading clickable"><span>误区</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mynote/docs/face/all.html" class="sidebar-heading clickable"><span>面经</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>浏览器原理</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">浏览器原理</h1> <div data-v-1ff7123e><!----> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2022/4/1</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><p>[TOC]</p> <p><img src="https://s2.loli.net/2022/03/26/Vx1wcfyEBaY3ngq.png" alt="浏览器原理面试题.png"></p> <h1 id="一、浏览器安全"><a href="#一、浏览器安全" class="header-anchor">#</a> 一、浏览器安全</h1> <h2 id="_1-什么是xss攻击"><a href="#_1-什么是xss攻击" class="header-anchor">#</a> 1. 什么是XSS攻击？</h2> <p><strong>（1）概念</strong></p> <p><strong>XSS攻击指的是跨站脚本攻击，是一种代码注入攻击</strong>。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如cookie等。</p> <p>XSS的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了 ，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p> <p>攻击者可以通过这种攻击方式进行以下操作：</p> <ul><li>获取页面的数据，如DOM、cookie、localStorage</li> <li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器</li> <li>破坏页面结构</li> <li>流量劫持（将链接指向某网站）</li></ul> <p><strong>（2）攻击类型</strong></p> <p>XSS可以分为存储型、反射型和DOM型：</p> <ul><li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回执行。</li> <li>反射型指的是攻击者诱导用户访问一个带有恶意代码的URL后，服务器端接收数据后处理，然后把带有恶意的代码的数据发送到浏览器端，浏览器端解析这段带有XSS代码的数据后当做脚本执行，最终完成XSS攻击</li> <li>DOM型指的通过修改页面的DOM节点形成XSS。</li></ul> <p><strong>（3）如何防御XSS攻击</strong>？</p> <ul><li>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到HTML中的代码做好充分的转义。对于DOM型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</li> <li>使用CSP（内容安全策略），CSP的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li> <li>对一些敏感信息进行保护，比如cookie使用 http-only ，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li></ul> <h2 id="_2-什么是csrf攻击"><a href="#_2-什么是csrf攻击" class="header-anchor">#</a> 2. 什么是CSRF攻击？</h2> <p><strong>（1）概念</strong></p> <p>CSRF攻击指的是 <strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p> <p>CSRF攻击的 <strong>本质是利用Cookie会在同源请求中携带发送给服务器的特点，以此来冒充用户</strong>。</p> <p><strong>（2）攻击类型</strong></p> <ul><li>GET类型的CSRF攻击，比如在网站中的一个img标签里构建一个请求，当用户打开这个网站时就会自动发起提交</li> <li>POST类型的CSRF攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单</li> <li>链接类型的CSRF攻击，比如在a标签的href属性里构建一个请求，然后诱导用户区点击。</li></ul> <p><strong>（3）如何防御CSRF攻击</strong></p> <ul><li><strong>进行同源检测</strong>。服务器根据http请求头中origin或者Referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。</li> <li>使用CSRF Token 进行验证</li> <li>对cookie进行双重验证</li> <li>在设置cookie属性的时候设置 Samesite，限制cookie不能作为被第三方使用。</li></ul> <h2 id="_3-什么是中间人攻击-如何防范中间人攻击"><a href="#_3-什么是中间人攻击-如何防范中间人攻击" class="header-anchor">#</a> 3. 什么是中间人攻击？如何防范中间人攻击？</h2> <p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容</p> <h1 id="二、进程与线程"><a href="#二、进程与线程" class="header-anchor">#</a> 二、进程与线程</h1> <h2 id="_1-进程与线程的概念"><a href="#_1-进程与线程的概念" class="header-anchor">#</a> 1.  进程与线程的概念</h2> <p>从本质上说，进程和线程都是CPU工作时间片的一个描述：</p> <ul><li>进程描述了CPU在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li> <li>线程是进程中的更小单位，描述了执行一段指令所需的时间。</li></ul> <p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong>。</p> <p>进程和线程之间的关系有以下四个特点：</p> <ol><li>进程中的任意一线程执行出错，都会导致整个进程崩溃</li> <li>线程之间共享进程中的数据</li> <li>当一个进程关闭后，操作系统会回收进程所占用的内存。</li> <li>进程之间的内容相互隔离</li></ol> <p><strong>Chrome浏览器的架构图</strong></p> <p><img src="https://s2.loli.net/2022/03/26/aEO21fyTCbgPcVs.png" alt="img"></p> <p>打开一个网页，至少需要四个进程：1个网络进程、1个浏览器进程、1个GPU进程和1个渲染进行。</p> <h2 id="_2-进程和线程的区别"><a href="#_2-进程和线程的区别" class="header-anchor">#</a> 2. 进程和线程的区别</h2> <ul><li>进程可以看做独立应用，线程不能</li> <li>资源：进程是CPU资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是CPU调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li> <li>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信</li> <li>调度：进程切换比线程切换的开销要大。线程切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li> <li>系统开销：进程的创建或撤销要大于线程。</li></ul> <h2 id="_3-浏览器渲染进程的线程有哪些"><a href="#_3-浏览器渲染进程的线程有哪些" class="header-anchor">#</a> 3. 浏览器渲染进程的线程有哪些</h2> <p>浏览器的渲染进程的线程共有5种：</p> <p><img src="https://s2.loli.net/2022/03/26/7v8jkl1dnsPqFwx.png" alt="img"></p> <p><strong>（1）GUI渲染进程</strong></p> <p>负责渲染浏览器页面，解析HTML、css、构建DOM树、构建CSSOM树，构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程执行。</p> <blockquote><p>注意：GUI渲染引擎线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会保存在一个队列中等到JS引擎空闲时立即被执行。</p></blockquote> <p><strong>（2）JS引擎线程</strong></p> <p>JS引擎线程也称为JS内核，负责处理JavaScript脚本程序，解析JavaScript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，如果然后加一处理，一个Tab页中无论什么时候都只有一个Js引擎线程在运行Js程序。</p> <blockquote><p>注意：GUI渲染线程与JS线程是互斥的，如果JS 执行时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p></blockquote> <p><strong>（3）事件触发线程</strong></p> <p>事件触发线程 属于浏览器而不是JS引擎，用来控制事件循环；当Js引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程，如鼠标点击，ajax异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合条件被触发时，该线程会把事件添加到待处理队列的队尾，等待Js引擎的处理。</p> <blockquote><p>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（Js引擎空闲时才会去执行）</p></blockquote> <p><strong>（4）定时器触发线程</strong></p> <p><strong>定时器触发线程</strong>即setInterval 与 setTimeOut 所在线程；浏览器定时器计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中。</p> <blockquote><p>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p></blockquote> <p><strong>（5）异步http请求线程</strong></p> <ul><li>XMLHTTPRequest连接后通过浏览器新开一个线程请求</li> <li>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行。</li></ul> <h2 id="_4-死锁问题"><a href="#_4-死锁问题" class="header-anchor">#</a> 4. 死锁问题</h2> <h3 id="什么是死锁"><a href="#什么是死锁" class="header-anchor">#</a> 什么是死锁</h3> <p>死锁就是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，他们都将无法再向前推进。</p> <h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="header-anchor">#</a> 产生死锁的原因</h3> <p><strong>（1）竞争资源</strong></p> <ul><li><strong>竞争不可剥夺资源</strong>（例：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li> <li><strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息顺序进行不当，则会产生死锁。</li></ul> <p><strong>（2）进程间推进顺序不当</strong></p> <p>例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p> <h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="header-anchor">#</a> 产生死锁的必要条件</h3> <ul><li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li> <li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li> <li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li> <li>环路等待条件：在发生死锁时，必然存在一个进程-------资源的环形链。</li></ul> <h3 id="预防死锁的方法"><a href="#预防死锁的方法" class="header-anchor">#</a> 预防死锁的方法</h3> <ul><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li> <li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请求保持条件）</li> <li>可剥夺资源：即当某进程获得了部分资源，但得不到其他资源，则释放已占有的资源（破坏不可剥夺条件）</li> <li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul> <h1 id="三、浏览器缓存"><a href="#三、浏览器缓存" class="header-anchor">#</a> 三、浏览器缓存</h1> <h2 id="_1-对浏览器的缓存机制的理解"><a href="#_1-对浏览器的缓存机制的理解" class="header-anchor">#</a> 1. 对浏览器的缓存机制的理解</h2> <p><strong>浏览器缓存的全过程</strong>：</p> <ul><li>浏览器第一次加载资源，服务器返回200，浏览器从服务器下载资源文件，并缓存资源文件与 <code>response header</code>，以供下次加载时使用；</li> <li>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回200时的时间差，如果没有超过<code>cache-control</code>设置的 <code>max-age</code>，则没有过期，并<strong>命中强缓存</strong>，直接从本地读取资源。如果浏览器不支持http1.1，则使用 <code>expires</code>头判断是否过期。</li> <li>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 <code>if-None-Match</code>和 <code>if-Modified-Since</code>的请求；</li> <li>服务器受到请求后，优先根据<code>ETag</code>的值判断被请求的文件有没有做修改，<code>ETag</code>值一致则没有修改，<strong>命中协商缓存</strong>，返回304；如果不一致有改动，直接返回新的资源文件带上新的<code>ETag</code>值并返回200</li> <li>如果服务器收到的请求没有<code>ETag</code>值，则将 <code>if-Modified-Since</code>和被请求文件的最后修改时间做对比，一致则命中协商缓存，返回304；不一致则返回新的 <code>last-modified</code>和文件并返回200.</li></ul> <blockquote><p>注释：</p> <ul><li><code>Etag</code> ：ETag为“被请求变量的实体值”。另一种说法是，Etag是一个可以与web资源关联的记号（token），典型的web资源可以是一个web页，也可是JSON或XML文档。例：<u>ETag:”50b1c1d4f775c61:df3”</u></li> <li><code>Last-Modified</code> ：浏览器第一次请求URL时，标记文件在服务端最后被修改的时间。例：<u>Last-Modified : Fri , 12 May 2018 18:53:33 GMT</u></li> <li><code>If-Modified-Since</code> ： 客户端第二次请求URL时，浏览器会向服务器传送If-Modified-Since报头，询问该时间之后文件是否有被修改过。<u>例：If-Modified-Since : Fri , 12 May 2018 18:53:33 GMT  </u></li> <li><strong>Expires</strong> ：Expires是RFC 2616（HTTP/1.0）协议中和网页缓存相关字段。用来控制缓存的失效日期，要注意的是，HTTP/1.0有一个功能比较弱的缓存控制机制：Pragma，使用HTTP/1.0的缓存将忽略Expires和Cache-Control头。</li> <li><strong>Cache-control</strong> ：Cache-Control 是最重要的规则。这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。</li></ul></blockquote> <p><img src="https://img-blog.csdn.net/20180723153657510?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1ZGFzaGk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="839281739281"></p> <p>很多网站的资源后面都加了版本号，这样做的目的是：每次升级了js文件或css文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的Js或CSS文件，以保证用户能够及时获得网站的最新更新。</p> <h2 id="_2-浏览器资源缓存的位置有哪些"><a href="#_2-浏览器资源缓存的位置有哪些" class="header-anchor">#</a> 2. 浏览器资源缓存的位置有哪些？</h2> <p>资源缓存的位置一共有3种，按优先级从高到低分别是：</p> <ul><li><strong>Service Worker</strong>：Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。</li> <li><strong>Memory Cache</strong>：内存缓存。它的效率最快，**但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。**一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</li> <li><strong>Disk Cache</strong>：磁盘缓存。</li></ul> <h2 id="_3-强缓存和协商缓存"><a href="#_3-强缓存和协商缓存" class="header-anchor">#</a> 3. 强缓存和协商缓存</h2> <p><a href="https://segmentfault.com/a/1190000008956069" target="_blank" rel="noopener noreferrer">HTTP强缓存和协商缓存 - SegmentFault 思否<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>（1）强缓存</strong></p> <p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发送请求。</p> <p>强缓存策略可以通过两种方式来设置，分别是http头信息中的 <code>Expires</code>属性和 <code>Cache-Control</code>属性</p> <p><strong>Cache-Control</strong>可以设置的字段：</p> <ul><li><code>public</code>：设置了该字段值的资源表示可以被任何对象缓存。</li> <li><code>private</code>：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。</li> <li><code>no-cache</code>：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源。</li> <li><code>no-store</code>：设置了该字段表示禁止任何缓存，每次都会向服务器发起新的请求，拉取最新的资源。</li> <li><code>max-age=</code>：设置缓存的最大有效期，单位为秒</li> <li><code>s-maxage=</code>：优先级高于max-age=，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li> <li><code>max-state[=]</code>：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li></ul> <p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，<strong>Cache-Control 的优先级要高于 Expires</strong>。</p> <p><strong>（2）协商缓存</strong></p> <p>如果命中强制协商，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。</p> <p>上面已经说到了，命中协商缓存的条件有两个：</p> <ul><li><code>max-age=xxx</code> 过期了</li> <li>值为<code>no-store</code></li></ul> <p><strong>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源</strong>。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结：</h3> <p>强制缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。他们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，他们是一起合作使用的。浏览器首先会根据请求的信息判断，强制缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p> <h2 id="_4-为什么需要浏览器缓存"><a href="#_4-为什么需要浏览器缓存" class="header-anchor">#</a> 4. 为什么需要浏览器缓存？</h2> <p>所谓的 <strong>浏览器缓存</strong> 指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p> <p>使用浏览器缓存的优点：</p> <ul><li>减少了服务器的负担，提高了网站的性能</li> <li>加快了客户端网页的加载速度</li> <li>减少了多余网络数据传输</li></ul> <h2 id="_5-点击刷新按钮或者按-f5、按-ctrl-f5-强制刷新-、地址栏回车有什么区别"><a href="#_5-点击刷新按钮或者按-f5、按-ctrl-f5-强制刷新-、地址栏回车有什么区别" class="header-anchor">#</a> 5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h2> <ul><li><p>**点击刷新按钮或者按 F5：**浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</p></li> <li><p>**用户按 Ctrl+F5（强制刷新）：**浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</p></li> <li><p>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</p></li></ul> <h1 id="四、浏览器组成"><a href="#四、浏览器组成" class="header-anchor">#</a> 四、浏览器组成</h1> <h2 id="_1-对浏览器的理解"><a href="#_1-对浏览器的理解" class="header-anchor">#</a> 1. 对浏览器的理解</h2> <p>浏览器可以分为两个部分：shell 和 内核</p> <ul><li><strong>shell</strong> 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。</li> <li><strong>内核</strong> 是浏览器的核心，内核是基于标记语言显示内容的程序或模块。</li></ul> <h2 id="_2-对浏览器内核的理解"><a href="#_2-对浏览器内核的理解" class="header-anchor">#</a> 2. 对浏览器内核的理解</h2> <p>浏览器内核主要分为两部分：</p> <ul><li>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示HTML、XML文档及图片，它也可以借助插件显示其他类型数据，例如使用PDF阅读器插件，可以显示PDF格式。</li> <li>JS引擎：解析和执行JavaScript来实现网页的动态效果。</li></ul> <p>最开始渲染引擎和Js引擎并没有区分的很明确，后来Js引擎越来越独立，内核就倾向于只指渲染引擎。</p> <h2 id="_4-常见浏览器所用内核"><a href="#_4-常见浏览器所用内核" class="header-anchor">#</a> 4. 常见浏览器所用内核</h2> <p>（1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p> <p>（2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p> <p>（3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p> <p>（4） Safari 浏览器内核：Webkit 内核；</p> <p>（5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p> <p>（6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p> <p>（7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p> <p>（8） 百度浏览器、世界之窗内核：IE 内核；</p> <p>（9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p> <p>（10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</p> <h1 id="五、浏览器渲染原理"><a href="#五、浏览器渲染原理" class="header-anchor">#</a> 五、浏览器渲染原理</h1> <h2 id="_1-浏览器渲染过程"><a href="#_1-浏览器渲染过程" class="header-anchor">#</a> 1. 浏览器渲染过程</h2> <ol><li>浏览器先对得到的HTML进行解析，之后进行网络资源的预处理，将以后要发送的请求提前加进请求队列中。</li> <li>浏览器将HTML转换为一个个的标记（标记化Tokenization），之后通过标记来构建DOM树；CSS同理，先进行标记化，再进行CSS样式树的构建。</li> <li>浏览器将DOM树和CSS样式树结合，生成渲染树。</li> <li>布局（回流）：浏览器根据渲染树，获取每个渲染树对象在屏幕上的位置和尺寸。</li> <li>绘制：将计算好的像素点绘制到屏幕</li> <li>渲染层合成：多个绘制后的渲染层按照恰当的重叠顺序进行合并，而后生成位图，最终通过显卡展示到屏幕上。</li></ol> <p><img src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603797939165-3bf54e28-5469-4093-a0e1-e0569cec1305.png?x-oss-process=image%2Fresize%2Cw_663%2Climit_0" alt="img"></p> <blockquote><p><strong>注意</strong>：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容 ，同时，可能还在通过网络下载其余内容。</p></blockquote> <h2 id="_2-浏览器渲染优化"><a href="#_2-浏览器渲染优化" class="header-anchor">#</a> 2. 浏览器渲染优化</h2> <p><strong>（1）针对JavaScript</strong></p> <p>JavaScript会阻塞HTML的解析，也会阻塞css的解析。</p> <ul><li><u><strong>尽量将JavaScript文件放在body的最后面</strong></u></li> <li><strong><u>body中间尽量不要写 <code>&lt;script&gt;</code>标签</u></strong></li> <li><code>&lt;script&gt;</code>标签的引入资源方式有三种，有一种就是常用的直接引入，还有两种就是使用 <code>async</code>属性和 <code>defer</code>属性来<strong>异步引入</strong>，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（<strong><u>尽量使用异步加载</u></strong>）。
<ul><li><strong>script</strong>：立即停止渲染页面去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</li> <li><strong>async</strong>：是在下载完成之后，立即异步加载，加载好后立即执行，多个async属性的标签，不能保证加载的顺序</li> <li><strong>defer</strong>：是在下载完成之后，立即异步加载。加载好后，如果DOM树还没构建好，则先等待DOM树解析好后再执行；如果DOM树已经准备好，则立即执行。多个带defer属性标签，按照顺序执行。</li></ul></li></ul> <p><strong>（2）针对CSS</strong></p> <ul><li><u><strong>导入外部样式使用link，而不用@import。</strong></u></li> <li><u><strong>如果css少，尽可能采用内嵌样式，直接写在style标签中。</strong></u></li></ul> <p>一般使用css有三种方式：使用 <strong>link、@import、内联样式</strong>，其中link和@import都是导入外部样式。区别如下：</p> <ul><li><strong>link</strong>：浏览器会派发一个新的线程（HTTP线程）去加载资源文件，与此同时GIUI渲染线程会继续向下渲染代码</li> <li><strong>@import</strong>：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染（阻碍浏览器渲染）。</li> <li><strong>style</strong>：GUI直接渲染</li></ul> <blockquote><p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器的默认样式，确保首次渲染的速度。所以CSS一般写在header中，让浏览器尽快发请求去获取CSS样式。</p></blockquote> <p><strong>（3）针对DOM树、CSSOM树</strong></p> <ul><li>HTML文件的代码层级尽量不要太深</li> <li>使用语义化的标签，来避免不标准语义化的特殊处理</li> <li>减少CSSD代码的层次，因为选择器是从左向右进行解析的。</li></ul> <p><strong>（4）减少回流与重绘</strong></p> <p><strong>渲染队列</strong>：浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次回流、重绘变成一次回流重绘。</p> <ul><li>操作DOM时，尽量在低层级的DOM节点进行操作</li> <li>不要使用table布局</li> <li>使用CSS的表达式</li> <li>不要频繁的操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li> <li>使用absolute或fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。</li> <li>将元素设置 <code>display:none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行DOM操作不会引发回流和重绘。</li> <li>使用CSS3中的 <code>transform，opacity，filters</code>属性，启动GPU加速，这些属性的改变不会引发回流或重绘。</li></ul> <h2 id="_3-什么是文档的预解析"><a href="#_3-什么是文档的预解析" class="header-anchor">#</a> 3. 什么是文档的预解析？</h2> <p>Webkit 和 Firefox都做了这个优化，当执行JavaScript脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。</p> <p>需要注意的是，预解析并不改变DOM树，它将这个工作留给主解析过程，自己只解析外部资源引用，比如外部脚本、样式表以及图片。</p> <h2 id="_4-css如何阻塞文档解析"><a href="#_4-css如何阻塞文档解析" class="header-anchor">#</a> 4. css如何阻塞文档解析？</h2> <p>理论上，既然样式表不改变DOM树，也就没有必要停下文档的解析等待他们。然而，存在一个问题，JavaScript脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟JavaScript脚本执行和文档的解析，直到其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM，然后再执行JavaScript，最后再继续文档的解析。</p> <h1 id="六、浏览器本地存储"><a href="#六、浏览器本地存储" class="header-anchor">#</a> 六、浏览器本地存储</h1> <h2 id="_1-浏览器本地存储方式以及使用场景"><a href="#_1-浏览器本地存储方式以及使用场景" class="header-anchor">#</a> 1. 浏览器本地存储方式以及使用场景</h2> <h3 id="_1-cookie-4kb"><a href="#_1-cookie-4kb" class="header-anchor">#</a> ① Cookie  4KB</h3> <p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4KB，它是一种纯文本文件，每次发起http请求都会携带Cookie</p> <p><strong>Cookie的特性</strong>：</p> <ul><li>Cookie一旦创建成功，名称就无法修改</li> <li><strong>Cookie是无法跨域名的</strong>，也就是说a域名和b域名下的Cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样能够阻止非法获取其他网站的Cookie。</li> <li>每个域名下的Cookie的数量不能超过20个，每个Cookie的大小不超过4kb</li> <li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补。</li> <li>Cookie在请求一个新的页面的时候都会被发送过去。</li></ul> <p><strong>如果需要域名之间跨域共享Cookie，有两种方法</strong>：</p> <ol><li>使用Nginx代理</li> <li>在一个站点登录之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储SessionId。</li></ol> <p><strong>Cookie的使用场景</strong>：</p> <ul><li>最常见的使用场景就是cookie和session结合使用，我们将sessionId存储到Cookie中，每次发送请求都会携带这个sessionId，这样服务器就知道是谁发起的请求，从而响应相应的信息。</li> <li>可以用来统计页面的点击次数。</li></ul> <h3 id="_2-localstorage-5m"><a href="#_2-localstorage-5m" class="header-anchor">#</a> ② LocalStorage  5M</h3> <p><strong>LocalStorage是html5新引入的特性</strong>，由于有时候存储的信息量较大，Cookie就不能满足我们的需求，这时候LocalStorage就可以使用了。</p> <p><strong>优点</strong>：</p> <ul><li>大小一般为5M，可以存储更多的信息</li> <li>是<strong>持久性存储</strong>，并不会随着页面的关闭而消失，除非主动清除，不然会永久存在。</li> <li><strong>仅存储在本地</strong>，不像Cookie那样每次HTTP请求都会被携带</li></ul> <p><strong>缺点</strong>：</p> <ul><li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li> <li>如果浏览器设置为隐私模式，那么我们将无法读取LocalStorage</li> <li>LocalStorage<strong>受到同源策略的限制</strong>，即端口、协议、主机地址有任何一个不相同，都不会访问。</li></ul> <p><strong>LocalStorage常用API</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//保存数据到LocalStorage</span>
LocalStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span><span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//从localStorage获取数据</span>
<span class="token keyword">let</span> data <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//从LocalStorage删除保存的数据</span>
localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//从localStorage删除所有保存的数据</span>
localStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//获取某个索引的key</span>
localStorage<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>使用场景</strong>：</p> <ul><li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可。</li> <li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li></ul> <h3 id="_3-sessionstorage-5m"><a href="#_3-sessionstorage-5m" class="header-anchor">#</a> ③ SessionStorage  5M</h3> <p>也是HTML5提出来的存储方案，sessionStorage主要用于<strong>临时保存</strong>同一窗口（或标签页）的数据，刷新页面是不会删除，关闭窗口或标签页之后将会删除这些数据。</p> <p><strong>SessionStorage和LocalStorage对比</strong>：</p> <ul><li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong></li> <li>SessionStorage也有同源策略的限制，但是SessionStorage <strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li> <li>两者都不能被爬虫爬取。</li></ul> <p><strong>SessionStorage的常用API</strong>：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 保存数据到 sessionStorage</span>
sessionStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 从 sessionStorage 获取数据</span>
<span class="token keyword">let</span> data <span class="token operator">=</span> sessionStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 从 sessionStorage 删除保存的数据</span>
sessionStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">'key'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 从 sessionStorage 删除所有保存的数据</span>
sessionStorage<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 获取某个索引的Key</span>
sessionStorage<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><strong>使用场景</strong>：</p> <p>由于sessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有<strong>临时</strong>的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</p> <h2 id="_2-cookie有哪些字段"><a href="#_2-cookie有哪些字段" class="header-anchor">#</a> 2. cookie有哪些字段？</h2> <ul><li><strong>Name</strong>：名称</li> <li><strong>Value</strong>：值，对于认证cookie，value值包括web服务器所提供的访问令牌</li> <li><strong>Size</strong>：大小</li> <li><strong>Path</strong>：可以访问cookie的页面路径</li> <li><strong>Secure</strong>：指定是否使用HTTPs安全协议发送Cookie。</li> <li><strong>Domain</strong>:可以访问该cookie的域名，cookie机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的Cookie。</li> <li><strong>HTTP</strong>：该字段包含<code>HTTPOnly</code> 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。</li> <li><strong>Expires/Max-size</strong>：此cookie的超时时间。</li></ul> <p><strong>总结</strong>：</p> <p>服务端可以使用 <strong>Set-Cookie</strong> 的响应头部来配置 cookie信息。一条cookie包括了5个属性值 <strong>expires</strong>、<strong>domain</strong>、<strong>path</strong>、<strong>secure</strong>、<strong>httpOnly</strong>。</p> <ul><li><strong>Expires</strong>：指定cookie的失效时间</li> <li><strong>domain和path</strong>：限制cookie能够哪些url访问。</li> <li><strong>secure</strong>：规定了Cookie只能在确保安全的情况下传输。</li> <li><strong>httpOnly</strong>：规定这个cookie只能被服务器访问，不能使用js脚本访问</li></ul> <h2 id="_3-前端存储的方式有哪些"><a href="#_3-前端存储的方式有哪些" class="header-anchor">#</a> 3. 前端存储的方式有哪些？</h2> <ul><li><strong>Cookie</strong>：由服务器设置，在客户端存储</li> <li><strong>localStorage</strong>：永久性存储，在本地存储</li> <li><strong>SessionStorage</strong>：临时存储，在本地存储</li> <li><strong>Web SQL</strong>：2010年被W3C废弃的本地数据库存储方案。</li> <li><strong>IndexedDB</strong>：是被正式纳入HTML5标准的数据库存储方案，它是NoSQL数据库，用键值对进行存储，可以进行快速读取操作，非常适合web场景，同时用JavaScript进行操作会非常方便。</li></ul> <h1 id="七、浏览器同源策略"><a href="#七、浏览器同源策略" class="header-anchor">#</a> 七、浏览器同源策略</h1> <h2 id="_1-什么是同源策略"><a href="#_1-什么是同源策略" class="header-anchor">#</a> 1. 什么是同源策略</h2> <p>跨域问题其实就是浏览器的同源策略引起的。</p> <p><strong>同源</strong>：指的是 协议（protocol）、端口（port）、域名（domain）必须一致。</p> <p><strong>同源策略</strong>：只有浏览器才受到同源策略的限制。即不同源的脚本在没有授权的情况下，不能读写对方的资源。比如我们打开了 <code>A.com</code>，之后又在没有许可的情况下向 <code>B.com</code>发送请求，通常这个请求是失败的。想要摆脱同源策略的限制，就要使用跨域的手段。</p> <p><strong>同源策略主要限制了三个方面</strong>：</p> <ul><li>当前域下的js脚本不能够访问其他域下的cookie、localStorage、indexDB。</li> <li>在当前域下的js脚本不能操作访问其他域下的DOM</li> <li>当前域下ajax无法发送跨域请求。</li></ul> <h2 id="_2-如何解决跨域问题"><a href="#_2-如何解决跨域问题" class="header-anchor">#</a> 2. 如何解决跨域问题</h2> <blockquote><p>最常用的是 CORS 和 反向代理</p></blockquote> <h3 id="cors"><a href="#cors" class="header-anchor">#</a> CORS</h3> <blockquote><p><code>CORS</code>（Cross-origin ResourceSharing）跨域资源共享机制，它使用额外的http头来告诉浏览器 让运行在一个origin（domain）上的web应用被准许访问来自不同源服务器上的指定资源。当一个资源从该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域http请求。</p></blockquote> <p><strong>CORS的关键是服务器，只要服务器实现了CORS请求，就可以跨源通信了</strong>。</p> <p>只需要后端在响应头设置 <code>Access-Control-Allow-Origin: *</code>，*表示任意origin，也可以指定Origin。</p> <p>使用CORS时默认不发送Cookie，想要发送Cookie需要：</p> <ol><li>设置 <code>Access-Control-Allow-Credentials:true</code></li> <li>此时 <code>Access-Control-Allow-Origin</code>不能设置为*，必须指定Origin</li></ol> <p>浏览器将CORS分为 <strong>简单请求</strong>和 <strong>非简单请求</strong>：</p> <p>简单请求不会触发CORS <strong>预检请求</strong>。</p> <p><strong>简单请求</strong>：</p> <blockquote><p>在简单请求中，在服务器内，至少需要设置字段 ：<code>Access-Control-Allow-Origin</code></p></blockquote> <ul><li>请求方法是：HEAD、GET、POST</li> <li>HTTP的头信息不超出以下几种字段：
<ul><li>Accept</li> <li>Accept-Language</li> <li>Content-Language</li> <li>Last-Event-ID</li> <li>Content-Type：只限制于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></li></ul> <p><u><strong>若不满足以上条件，就属于非简单请求了</strong></u></p> <p><strong>（1）简单请求过程</strong>：</p> <p>对于简单请求，浏览器会直接发出CORS请求，它会在请求头信息中增加一个Origin字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Origin指定的域名在许可范围之内服务器返回的响应就会多出以下信息头：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>com  <span class="token comment">// 和Orign一直</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token operator">:</span> <span class="token boolean">true</span>   <span class="token comment">// 表示是否允许发送Cookie</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Expose<span class="token operator">-</span>Headers<span class="token operator">:</span> FooBar   <span class="token comment">// 指定返回其他字段的值</span>
Content<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>   <span class="token comment">// 表示文档类型</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果Origin指定的域名不在许可范围之内，服务器会返回一个正常的http回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误时无法通过状态码识别，因为返回的状态码可能是200.</p> <p><strong>（2）非简单请求</strong></p> <p>非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，称为 <strong>预检请求</strong>。</p> <p>预检请求使用的方法是 <strong>OPTIONS</strong>，表示这个请求是来询问的。他的头信息中包括以下字段：</p> <ul><li><strong>Access-Control-Request-Origin</strong>：表示请求来自哪个源。</li> <li><strong>Access-Control-Request-Method</strong>：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</li> <li><strong>Access-Control-Request-Headers</strong>：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</li></ul> <p>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，服务器回应的CORS字段如下：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>com  <span class="token comment">// 允许跨域的源地址</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods<span class="token operator">:</span> <span class="token constant">GET</span><span class="token punctuation">,</span> <span class="token constant">POST</span><span class="token punctuation">,</span> <span class="token constant">PUT</span> <span class="token comment">// 服务器支持的所有跨域请求的方法</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers<span class="token operator">:</span> <span class="token constant">X</span><span class="token operator">-</span>Custom<span class="token operator">-</span>Header  <span class="token comment">// 服务器支持的所有头信息字段</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token operator">:</span> <span class="token boolean">true</span>   <span class="token comment">// 表示是否允许发送Cookie</span>
Access<span class="token operator">-</span>Control<span class="token operator">-</span>Max<span class="token operator">-</span>Age<span class="token operator">:</span> <span class="token number">1728000</span>  <span class="token comment">// 用来指定本次预检请求的有效期，单位为秒</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果返回的头信息中有 Access-Control-Allow-Origin这个字段就是允许跨域请求。</p> <h3 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> JSONP</h3> <p><strong>jsonp</strong>的原理就是利用 <code>&lt;script&gt;</code>标签没有跨域限制，通过 <code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回的数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span><span class="token punctuation">;</span>
    <span class="token comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span>
    script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'</span><span class="token punctuation">;</span>
    document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 回调执行函数</span>
    <span class="token keyword">function</span> <span class="token function">handleCallback</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>服务端返回如下（返回时即执行全局函数）：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">handleCallback</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string-property property">&quot;success&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string-property property">&quot;user&quot;</span><span class="token operator">:</span> <span class="token string">&quot;admin&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>缺点</strong>：仅支持get方法，不安全，可能会受到XSS攻击。</p> <h3 id="postmessage-跨域"><a href="#postmessage-跨域" class="header-anchor">#</a> postMessage 跨域</h3> <p>postMessage是HTML5 XMLHttpRequest Level2中的API。</p> <p>用法： <code>postMessage(data,origin)</code></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span>
window<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="反向代理"><a href="#反向代理" class="header-anchor">#</a> 反向代理</h3> <p>由于同源策略是浏览器的策略。</p> <p><code>A.com:80</code>不能向 <code>B.com:3000</code>发送请求。那么我们可以在 <code>A.com:8080</code>设置一个代理服务器来代理请求，之后发请求就是 <code>A.com:80 -&gt; A.com:8080 -&gt;B.com:3000</code>,此时请求可以成功发过去。</p> <p>通常我们本地开发项目是使用 <code>webpack-dev-server</code>，而它自带了代理服务器的功能（只需要我们在配置文件中加上 <code>proxy</code>），所以可以轻松解决跨域问题。除此之外我们也可以使用 <code>nginx</code>来反向代理。</p> <h4 id="nginx代理跨域"><a href="#nginx代理跨域" class="header-anchor">#</a> nginx代理跨域</h4> <p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin...等字段</p> <p><strong>（1）nginx配置解决iconfont跨域</strong></p> <p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件（eot|otf|ttf|woff|svg）例外，此时可在nginx的静态资源服务器中加入以下配置</p> <div class="language-http line-numbers-mode"><pre class="language-http"><code>location / {
	add_header Access-Control-Allow-Origin *;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>（2）nginx反向代理接口跨域</strong></p> <p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p> <p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p> <div class="language-nginx line-numbers-mode"><pre class="language-nginx"><code><span class="token comment">#proxy服务器</span>
<span class="token directive"><span class="token keyword">server</span></span> <span class="token punctuation">{</span>
    <span class="token directive"><span class="token keyword">listen</span>		<span class="token number">81</span></span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">server_name</span>	www.domain1.com</span><span class="token punctuation">;</span>
    <span class="token directive"><span class="token keyword">location</span> /</span> <span class="token punctuation">{</span>
        <span class="token directive"><span class="token keyword">proxy_pass</span>	http://www.domain2.com:8080</span><span class="token punctuation">;</span>  <span class="token comment">#反向代理</span>
        <span class="token directive"><span class="token keyword">proxy_cookie_domain</span> www.domain2.com www.domain1.com</span><span class="token punctuation">;</span> <span class="token comment">#修改cookie里域名</span>
        <span class="token directive"><span class="token keyword">index</span>  index.html index.htm</span><span class="token punctuation">;</span>
        <span class="token comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span>
        <span class="token directive"><span class="token keyword">add_header</span> Access-Control-Allow-Origin http://www.domain1.com</span><span class="token punctuation">;</span>  <span class="token comment">#当前端只跨域不带cookie时，可为*</span>
        <span class="token directive"><span class="token keyword">add_header</span> Access-Control-Allow-Credentials true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="document-domain"><a href="#document-domain" class="header-anchor">#</a> document.domain</h3> <p>此方案仅限主域相同，子域不同的跨域应用场景。</p> <p>实现原理：两个页面都通过JS强制设置document.domain为基础主域，就实现了同域。</p> <p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。</p> <p>如a.example.com和b.example.com。</p> <p><strong>此时两个网站都设置 <code>document.domain = &quot;example.com&quot;</code>， 那么两个网页就可以共享Cookie了。</strong></p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//a.example.com</span>
document<span class="token punctuation">.</span>cookie <span class="token operator">=</span> <span class="token string">'aaa'</span>
<span class="token comment">//b.examlpe.com</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span>cookie<span class="token punctuation">)</span> <span class="token comment">//'aaa'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="location-hash-iframe-跨域"><a href="#location-hash-iframe-跨域" class="header-anchor">#</a> location.hash + iframe 跨域</h3> <p><strong>实现原理</strong>：a欲与b跨域相互通信，通过中间页c来实现。三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js来访问</p> <p><strong>具体实现</strong>：A域（a.html)  -&gt;  B域（b.html）-&gt; A域（c.html）。a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以可以通过parent.parent访问a页面所有对象。</p> <p>（1）a.html：（domain1.com/a.html)</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>iframe id<span class="token operator">=</span><span class="token string">&quot;iframe&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;http://www.domain2.com/b.html&quot;</span> style<span class="token operator">=</span><span class="token string">&quot;display:none;&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">var</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 向b.html传hash值</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> iframe<span class="token punctuation">.</span>src <span class="token operator">+</span> <span class="token string">'#user=admin'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 开放给同域c.html的回调方法</span>
    <span class="token keyword">function</span> <span class="token function">onCallback</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'data from c.html ---&gt; '</span> <span class="token operator">+</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>（2）b.html：(.domain2.com/b.html)</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>iframe id<span class="token operator">=</span><span class="token string">&quot;iframe&quot;</span> src<span class="token operator">=</span><span class="token string">&quot;http://www.domain1.com/c.html&quot;</span> style<span class="token operator">=</span><span class="token string">&quot;display:none;&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>iframe<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">var</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 监听a.html传来的hash值，再传给c.html</span>
    window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        iframe<span class="token punctuation">.</span>src <span class="token operator">=</span> iframe<span class="token punctuation">.</span>src <span class="token operator">+</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>3）c.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/c.html" target="_blank" rel="noopener noreferrer">http://www.domain1.com/c.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token comment">// 监听b.html传来的hash值</span>
    window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 再通过操作同域a.html的js回调，将结果传回</span>
        window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">onCallback</span><span class="token punctuation">(</span><span class="token string">'hello: '</span> <span class="token operator">+</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'#user='</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="window-name"><a href="#window-name" class="header-anchor">#</a> window.name</h3> <p>这个方法主要用于<strong>父窗口和iframe窗口的通信</strong>。</p> <p>如果父窗口和iframe窗口是不同源的，则通常无法进行通信。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- 我是父窗口 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>xxx.com<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!-- 我是子窗口 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>window.name</code>特点：无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。</p> <p>例如，我们在a.com页面下设置</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>window<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'123'</span>
location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token string">'b.com'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>然后在b.com也能获取到<code>window.name</code>的值。</p> <p>实现跨域：</p> <p>使用时，先设置<code>iframe</code>的<code>src</code>为我们想要通信的目标页面。当目标页面的<code>window.name</code>修改时，将我们的<code>iframe</code>的<code>src</code>修改为一个和父窗口同源的页面。</p> <p>本质：</p> <p>iframe内的目标页面 &lt;=&gt; iframe内的一个和父窗口同源的页面 &lt;=&gt; 父窗口</p> <h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h3> <ul><li>CORS</li> <li>JSONP</li> <li>反向代理</li> <li>postMessage</li> <li>document.domain</li> <li>location.hash + iframe</li> <li>window.name</li></ul> <h2 id="_3-正向代理和反向代理的区别"><a href="#_3-正向代理和反向代理的区别" class="header-anchor">#</a> 3. 正向代理和反向代理的区别</h2> <p><strong>正向代理</strong></p> <p>客户端想要获取一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。<strong>实现正向代理需要修改客户端，比如修改浏览器配置。</strong></p> <p><strong>反向代理</strong></p> <p>服务器为了能够将工作负载分发到多个服务器来提高网站性能（负载均衡）等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。</p> <p>一般使用反向代理后，需要通过修改DNS让 域名解析到代理服务器IP，这时浏览器无法察觉到真正的服务器的存在，当然也就不需要修改配置了。</p> <p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1500604/1605256274960-50bd9e69-dde9-4782-b2c0-6afc8188fca2.jpeg?x-oss-process=image%2Fresize%2Cw_522%2Climit_0" alt="img"></p> <blockquote><p>正向代理和反向代理的结构是一样的，都是client-proxy-server的结构，他们主要的区别就在于中间这个proxy是哪一方设置的。在正向代理中，proxy是client设置的，用来隐藏client；在反向代理中，proxy是server设置的，用来隐藏server。</p></blockquote> <h1 id="八、浏览器事件机制"><a href="#八、浏览器事件机制" class="header-anchor">#</a> 八、浏览器事件机制</h1> <h2 id="_1-事件是什么-事件模型"><a href="#_1-事件是什么-事件模型" class="header-anchor">#</a> 1. 事件是什么？事件模型？</h2> <p><strong>事件</strong>是用户操作网页时发生的交互动作，比如click/move，事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个event对象，包含了该事件发生时的所有相关信息（event 的属性）以及可以对事件进行的操作（event方法）。</p> <p><strong>事件是用户操作网页时发生的交互动作或者网页本身的一些操作</strong>，现代浏览器一共有三种事件模型：</p> <ul><li><strong>DOM 0级事件模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过js属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0 写法。</li> <li><strong>IE 事件模型</strong>，该事件模型中，一次事件共有两个过程，<strong>事件处理</strong>阶段和<strong>事件冒泡</strong>阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li> <li><strong>DOM2级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是<strong>事件捕获</strong>阶段。捕获指的是事件从document一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和IE事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li></ul> <h2 id="_2-如何阻止事件冒泡"><a href="#_2-如何阻止事件冒泡" class="header-anchor">#</a> 2. 如何阻止事件冒泡</h2> <ul><li>普通浏览器使用：<code>event.stopPropagation()</code></li> <li>IE浏览器使用：<code>event.cancelBubble = true</code></li></ul> <h2 id="_3-对事件委托的理解"><a href="#_3-对事件委托的理解" class="header-anchor">#</a> 3. 对事件委托的理解</h2> <p><strong>（1）事件委托的概念</strong></p> <p>事件委托本质上是利用了 <strong>浏览器事件冒泡</strong> 的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为<strong>事件委托（事件代理）</strong>。</p> <p>使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。</p> <p><strong>（2）事件委托的特点</strong></p> <ul><li>减少内存消耗</li> <li>动态绑定事件</li></ul> <p>例子：如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件，我们可以把点击事件绑定在他的父级，也就是ul上。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>item 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>item 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    ...
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>item n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token comment">//给父层元素绑定事件</span>
document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//兼容性处理</span>
    <span class="token keyword">var</span> event <span class="token operator">=</span> e <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
    <span class="token keyword">var</span> target <span class="token operator">=</span> event<span class="token punctuation">.</span>target <span class="token operator">||</span> event<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
    <span class="token comment">//判断是否匹配目标元素</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span>toLocaleLowerCase <span class="token operator">===</span> <span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'the content is:'</span><span class="token punctuation">,</span>target<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在上述代码中，target元素则是在#list元素之下具体被点击的元素，然后通过判断target的一些属性（比如：nodeName，id等等）可以更精确地匹配到某一类#list li 元素之上。</p> <p><strong>（3）事件委托的局限性</strong></p> <p>focus、blur之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</p> <p>事件委托会影响页面的性能，主要影响因素有：</p> <ul><li>元素中，绑定事件委托的次数；</li> <li>点击最底层的元素，到绑定事件元素之间的DOM层数</li></ul> <p>在必须使用事件委托的地方，可以进行如下处理：</p> <ul><li>只在必须的地方，使用事件委托，比如：ajax的局部刷新区域</li> <li>尽量的减少绑定的层级，不在body元素上进行绑定</li> <li>减少绑定的次数，如果可以，那么把多个事件绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。</li></ul> <h2 id="_4-同步和异步的区别"><a href="#_4-同步和异步的区别" class="header-anchor">#</a> 4. 同步和异步的区别</h2> <ul><li><strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li> <li><strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</li></ul> <h2 id="_5-对事件循环的理解"><a href="#_5-对事件循环的理解" class="header-anchor">#</a> 5. 对事件循环的理解</h2> <p>因为Js是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果有遇到异步事件，js引擎并不会一直等待其返回结果，而是会将整个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，在将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js引擎会首先判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。</p> <p><img src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476500217-472563e1-de67-403f-baa7-0fd574d0e618.png?x-oss-process=image%2Fresize%2Cw_1237%2Climit_0" alt="img"></p> <p><strong>事件循环（event Loop）执行顺序如下所示</strong>：</p> <ul><li>首先执行同步代码，这属于宏任务（也就是所说的script脚本中的代码）</li> <li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li> <li>执行所有微任务</li> <li>当执行完所有微任务后，如有必要会渲染页面</li> <li>然后开始下一轮event Loop，执行宏任务中的异步代码</li></ul> <h2 id="_6-什么是执行栈"><a href="#_6-什么是执行栈" class="header-anchor">#</a> 6. 什么是执行栈？</h2> <p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。</p> <p>当开始执行js代码时，根据先进后出的原则，后执行的函数会先弹出栈。</p> <p><img src="https://s2.loli.net/2022/03/26/aXVq24R6cjnvDpt.gif" alt="img"></p> <h2 id="_7-事件触发的过程是怎样的"><a href="#_7-事件触发的过程是怎样的" class="header-anchor">#</a> 7. 事件触发的过程是怎样的？</h2> <p>事件触发有三个阶段：</p> <ul><li><code>window</code>往事件触发处传播，遇到注册的捕获事件会触发</li> <li>传播到事件触发处时触发注册的事件</li> <li>从事件触发处往 <code>window</code>传播，遇到注册的冒泡事件会触发。</li></ul> <p>事件触发一般来说会按照上面的顺序执行，但是也有特例，<strong>如果给一个body中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</strong>。</p> <h1 id="九、浏览垃圾回收机制"><a href="#九、浏览垃圾回收机制" class="header-anchor">#</a> 九、浏览垃圾回收机制</h1> <ul><li><a href="https://blog.csdn.net/qq_20282263/article/details/88694143" target="_blank" rel="noopener noreferrer">浏览器垃圾回收机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://mp.weixin.qq.com/s/YAvBfY7cF8WUm5XuJDoYTg" target="_blank" rel="noopener noreferrer">深入理解Chrome V8垃圾回收机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6995706341041897486" target="_blank" rel="noopener noreferrer">图解v8垃圾回收机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>对于栈的内存空间，只保存简单数据类型的内存，由操作系统自动分配和自动释放。而堆空间中的内存，由于大小不固定，系统无法进行自动释放，这个时候就需要js引擎来手动的释放这些内存。当我们的代码没有按照正确的写法时，会使得Js引擎的垃圾回收机制无法正确的对内存进行释放（内存泄漏），从而使得浏览器占用的内存不断增加，进而导致JavaScript和应用、操作系统性能下降。</p> <h2 id="_1-什么是内存泄漏-哪些操作会造成内存泄漏"><a href="#_1-什么是内存泄漏-哪些操作会造成内存泄漏" class="header-anchor">#</a> 1. 什么是内存泄漏？哪些操作会造成内存泄漏？</h2> <p><strong><code>内存泄漏</code>是指你向系统申请分配内存进行使用，然后系统在堆内存中给这个对象申请一块内存空间，但当我们使用完了却没有归系统，导致这个不使用的对象一直占据内存单元，造成系统将不能再把它分配给需要的程序。</strong></p> <ul><li>第一种是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li> <li>第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li> <li>第三种情况是获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了这个元素的引用，所以它也无法被回收</li> <li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存中。</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/mynote/docs/note/Computer-network/Computer-network.html" class="prev">
            计算机网络
          </a></span> <span class="next"><a href="/mynote/docs/note/engineering&amp;optimization/Babel.html">
            Babel
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_1-什么是xss攻击" class="sidebar-link reco-side-_1-什么是xss攻击" data-v-70334359>1. 什么是XSS攻击？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_2-什么是csrf攻击" class="sidebar-link reco-side-_2-什么是csrf攻击" data-v-70334359>2. 什么是CSRF攻击？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_3-什么是中间人攻击-如何防范中间人攻击" class="sidebar-link reco-side-_3-什么是中间人攻击-如何防范中间人攻击" data-v-70334359>3. 什么是中间人攻击？如何防范中间人攻击？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_1-进程与线程的概念" class="sidebar-link reco-side-_1-进程与线程的概念" data-v-70334359>1.  进程与线程的概念</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_2-进程和线程的区别" class="sidebar-link reco-side-_2-进程和线程的区别" data-v-70334359>2. 进程和线程的区别</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_3-浏览器渲染进程的线程有哪些" class="sidebar-link reco-side-_3-浏览器渲染进程的线程有哪些" data-v-70334359>3. 浏览器渲染进程的线程有哪些</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_4-死锁问题" class="sidebar-link reco-side-_4-死锁问题" data-v-70334359>4. 死锁问题</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#什么是死锁" class="sidebar-link reco-side-什么是死锁" data-v-70334359>什么是死锁</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#产生死锁的原因" class="sidebar-link reco-side-产生死锁的原因" data-v-70334359>产生死锁的原因</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#产生死锁的必要条件" class="sidebar-link reco-side-产生死锁的必要条件" data-v-70334359>产生死锁的必要条件</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#预防死锁的方法" class="sidebar-link reco-side-预防死锁的方法" data-v-70334359>预防死锁的方法</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_1-对浏览器的缓存机制的理解" class="sidebar-link reco-side-_1-对浏览器的缓存机制的理解" data-v-70334359>1. 对浏览器的缓存机制的理解</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_2-浏览器资源缓存的位置有哪些" class="sidebar-link reco-side-_2-浏览器资源缓存的位置有哪些" data-v-70334359>2. 浏览器资源缓存的位置有哪些？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_3-强缓存和协商缓存" class="sidebar-link reco-side-_3-强缓存和协商缓存" data-v-70334359>3. 强缓存和协商缓存</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#总结" class="sidebar-link reco-side-总结" data-v-70334359>总结：</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_4-为什么需要浏览器缓存" class="sidebar-link reco-side-_4-为什么需要浏览器缓存" data-v-70334359>4. 为什么需要浏览器缓存？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_5-点击刷新按钮或者按-f5、按-ctrl-f5-强制刷新-、地址栏回车有什么区别" class="sidebar-link reco-side-_5-点击刷新按钮或者按-f5、按-ctrl-f5-强制刷新-、地址栏回车有什么区别" data-v-70334359>5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_1-对浏览器的理解" class="sidebar-link reco-side-_1-对浏览器的理解" data-v-70334359>1. 对浏览器的理解</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_2-对浏览器内核的理解" class="sidebar-link reco-side-_2-对浏览器内核的理解" data-v-70334359>2. 对浏览器内核的理解</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_4-常见浏览器所用内核" class="sidebar-link reco-side-_4-常见浏览器所用内核" data-v-70334359>4. 常见浏览器所用内核</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_1-浏览器渲染过程" class="sidebar-link reco-side-_1-浏览器渲染过程" data-v-70334359>1. 浏览器渲染过程</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_2-浏览器渲染优化" class="sidebar-link reco-side-_2-浏览器渲染优化" data-v-70334359>2. 浏览器渲染优化</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_3-什么是文档的预解析" class="sidebar-link reco-side-_3-什么是文档的预解析" data-v-70334359>3. 什么是文档的预解析？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_4-css如何阻塞文档解析" class="sidebar-link reco-side-_4-css如何阻塞文档解析" data-v-70334359>4. css如何阻塞文档解析？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_1-浏览器本地存储方式以及使用场景" class="sidebar-link reco-side-_1-浏览器本地存储方式以及使用场景" data-v-70334359>1. 浏览器本地存储方式以及使用场景</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_1-cookie-4kb" class="sidebar-link reco-side-_1-cookie-4kb" data-v-70334359>① Cookie  4KB</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_2-localstorage-5m" class="sidebar-link reco-side-_2-localstorage-5m" data-v-70334359>② LocalStorage  5M</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_3-sessionstorage-5m" class="sidebar-link reco-side-_3-sessionstorage-5m" data-v-70334359>③ SessionStorage  5M</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_2-cookie有哪些字段" class="sidebar-link reco-side-_2-cookie有哪些字段" data-v-70334359>2. cookie有哪些字段？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_3-前端存储的方式有哪些" class="sidebar-link reco-side-_3-前端存储的方式有哪些" data-v-70334359>3. 前端存储的方式有哪些？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_1-什么是同源策略" class="sidebar-link reco-side-_1-什么是同源策略" data-v-70334359>1. 什么是同源策略</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_2-如何解决跨域问题" class="sidebar-link reco-side-_2-如何解决跨域问题" data-v-70334359>2. 如何解决跨域问题</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#cors" class="sidebar-link reco-side-cors" data-v-70334359>CORS</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#jsonp" class="sidebar-link reco-side-jsonp" data-v-70334359>JSONP</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#postmessage-跨域" class="sidebar-link reco-side-postmessage-跨域" data-v-70334359>postMessage 跨域</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#反向代理" class="sidebar-link reco-side-反向代理" data-v-70334359>反向代理</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#document-domain" class="sidebar-link reco-side-document-domain" data-v-70334359>document.domain</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#location-hash-iframe-跨域" class="sidebar-link reco-side-location-hash-iframe-跨域" data-v-70334359>location.hash + iframe 跨域</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#window-name" class="sidebar-link reco-side-window-name" data-v-70334359>window.name</a></li><li class="level-3" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#总结-2" class="sidebar-link reco-side-总结-2" data-v-70334359>总结</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_3-正向代理和反向代理的区别" class="sidebar-link reco-side-_3-正向代理和反向代理的区别" data-v-70334359>3. 正向代理和反向代理的区别</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_1-事件是什么-事件模型" class="sidebar-link reco-side-_1-事件是什么-事件模型" data-v-70334359>1. 事件是什么？事件模型？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_2-如何阻止事件冒泡" class="sidebar-link reco-side-_2-如何阻止事件冒泡" data-v-70334359>2. 如何阻止事件冒泡</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_3-对事件委托的理解" class="sidebar-link reco-side-_3-对事件委托的理解" data-v-70334359>3. 对事件委托的理解</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_4-同步和异步的区别" class="sidebar-link reco-side-_4-同步和异步的区别" data-v-70334359>4. 同步和异步的区别</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_5-对事件循环的理解" class="sidebar-link reco-side-_5-对事件循环的理解" data-v-70334359>5. 对事件循环的理解</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_6-什么是执行栈" class="sidebar-link reco-side-_6-什么是执行栈" data-v-70334359>6. 什么是执行栈？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_7-事件触发的过程是怎样的" class="sidebar-link reco-side-_7-事件触发的过程是怎样的" data-v-70334359>7. 事件触发的过程是怎样的？</a></li><li class="level-2" data-v-70334359><a href="/mynote/docs/note/browser/browser.html#_1-什么是内存泄漏-哪些操作会造成内存泄漏" class="sidebar-link reco-side-_1-什么是内存泄漏-哪些操作会造成内存泄漏" data-v-70334359>1. 什么是内存泄漏？哪些操作会造成内存泄漏？</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/mynote/assets/js/app.7fa68d6d.js" defer></script><script src="/mynote/assets/js/3.50452af2.js" defer></script><script src="/mynote/assets/js/1.6e2e339d.js" defer></script><script src="/mynote/assets/js/37.5acf7413.js" defer></script>
  </body>
</html>
